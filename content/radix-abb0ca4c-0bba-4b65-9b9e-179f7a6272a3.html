<!--?xml version="1.0" encoding="UTF-8"?--><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head></head>
  <body><meta charset="utf-8"><meta charset="utf-8"><h1 dir="ltr"><span>Prefix Search using Radix Tree</span></h1><b id="docs-internal-guid-d2f29dbf-013c-f68a-aaa3-d6af1e10e23e"><p style=""><br></p><p style=""><u></u><b><u>Group</u>:</b></p></b><p><b id="">Toshahnvie Mangal (10103651)</b></p><p><b>Harshal Jain (10103538)</b></p><p><b id="">Ashish Dubey (10103585)</b></p><b><p style=""><br style=""><span></span></p></b><h2><b><span>Problem</span><br style=""><span></span></b></h2><p>Given a prefix (a sequence of characters), and a set of strings, find the subset of strings that begin with the prefix.</p><p dir="ltr"><b><span>Example</span><span>:</span></b></p><p dir="ltr"><span>Set of strings: {romane, romanus, romulus, rubens, ruber, rubicon, rubicundus}</span></p><p dir="ltr"><span>Prefix: roma</span></p><p dir="ltr"><span>Output set of strings: {romane, romanus}</span></p><br><span></span><p dir="ltr"><span>Such a problem is commonly seen as application features like auto-complete, suggestions, IP routing, etc.&nbsp;</span><br style=""><span></span><span>If we want to build an auto-complete feature, we must solve this problem in a way that is robust and efficient as in a typical applications the set of strings would be fairly large and we want to guarantee the best possible running time in a space efficient manner.</span></p><p dir="ltr"><span>Here we try to incrementally solve the problem in a way that could have been a possible thought process of the original solver of the problem.</span></p><b><br><span></span></b><h2><b><span>Solution Approaches</span><br style=""><span></span></b></h2><p style="">1. <b>Naive matching</b> - Matching all the strings with the prefix character by character.<br style=""><span></span></p><p style=""><span>In the above example - “roma” is matched with each string in the set, and all the strings that match are returned in the output set.</span><br style=""><span></span></p><p style=""><span>The time complexity for this approach would be O(n*m) where n is the number of strings in the set and m is the length of the prefix as in the worst case where all the strings match in the set, there would be exactly m comparisons for each string hence the total comparisons would be n*m.</span></p><p style=""><br style=""><span></span></p><p style="">2. <b>Filtered matching</b> - This approach works in a way that all the strings that start with a prefix of the prefix will only be matched with the original prefix.<br style=""><span></span></p><p><span><b>Example</b></span><span>:</span></p><p><span>For the prefix: “roma”</span></p><p style=""><span>We can be assured that only strings starting with “r” will be containing “roma” as prefix. Hence all the strings should be considered as the candidates in the above example.</span><br style=""><span></span></p><p style=""><span>Next we take, “ro”, which gives us the set {“romane”, “romanus”, “romulus”}.</span><br style=""><span></span></p><p style=""><span>We further, try to narrow down our set by taking the prefix “rom”, which actually does not narrow down the current candidate set. So we finally consider “roma”, which gives the output set {“romane”, “romanus”} which is our final output set.</span><br style=""><span></span></p><p style=""><span>So, as it can be seen, although, the filtered approach in a way is similar to naive matching if we do it on runtime everytime a prefix match is required. But if we’re clever about it, using some space we can index this at each filter level, which can significantly boost our queries. As we won’t need to do string matching at each level.</span><br style=""><span></span></p><p style=""><span>Example</span><span>: If we already had the information of the matching set for prefix “rom”, {“romane”, “romanus, “romulus”} it would be easier to pick the resulting set of strings matching with “roma”.</span><br style=""><span></span></p><p style=""><span>This approach will also require us to index the resulting sets for other possible prefixes that may be used in the query.</span><br style=""><span></span></p><p><br></p><p style=""><span><b>Example</b></span><span>:</span><br style=""><span></span></p><p><span>For prefix “ru” -&gt; {“rubens”, “ruber”, “rubicon”, “rubicundus”}</span></p><p><span>For prefix “rub” -&gt; {“rubens”, “ruber”, “rubicon”, “rubicundus”}</span></p><p><span>For prefix “rube” -&gt; {“rubens”, “ruber”}</span></p><p><span>For prefix “rubi” -&gt; {“rubicon”, “rubicundus”}</span></p><p><span>For prefix “rubic” -&gt; {“rubicon”, “rubicundus”}</span></p><p><span>For prefix “rubico” -&gt; {“rubicon”}</span></p><p style=""><span>For prefix “rubicu” -&gt; {“rubicundus”}</span></p><p style=""><br style=""><span></span></p><p><span>One important thing we have to figure out here is that how to store this information of indexed result sets. Its noticeable that the prefix sets form a hierarchy where, smaller prefixes contain larger result sets and as the prefixes get longer, the resulting sets become the subsets of the resulting sets of the shorter prefix. Such a relation inspires us to attempt storing this data in a tree based data structure.</span></p><p style=""><span>Also, if we notice the above example, there is a possibility of prefixes whose resulting sets don’t change. For example, “rubi”, and “rubic” both have resulting sets {“rubicon”, “rubicundus”}. Since coming from “rubi” to “rubic” does not change the resulting sets we can simply drop “rubi”. After this optimization our final tree would look like this:</span></p><p><br><span></span><img src="https://lh3.googleusercontent.com/_66Gqa3dHLD-WgrHu3716n5Pr0SOlgL3N3h9m9YG0RSUh49Z3UoRmuZfSGFqZagy_yWJQLbpyiRtaGjO6jyq9fSfnV0__C9J3163_ARhhqkzLqX2AXoznJK_SL-5CA" width="550px;" height="345px;" alt="640px-Patricia_trie.svg.png" class="" style="height: 344px; width: 550px; position: relative; margin: 0px; resize: none; zoom: 1; display: inline-block; top: 0px; left: 0px;"><span></span></p><p><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<em>Image source Wikipedia</em>)</span><br style=""><span></span></p><p><br></p><p><span>With such a tree, the query time comes out to be O(k) where k = maximum length of all strings in the set. Which means it runs way faster than the naive matching method in a case where n &gt;&gt; k. This is usually the case in auto-complete applications which use dictionary of thousands of words of short length.</span></p><p><br class="Apple-interchange-newline"></p>
</body></html>