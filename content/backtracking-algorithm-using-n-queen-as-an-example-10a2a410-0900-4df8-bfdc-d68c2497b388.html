<!--?xml version="1.0" encoding="UTF-8"?--><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head></head>
  <body><meta http-equiv="content-type" content="text/html; charset=utf-8" style=""><meta charset="utf-8" style=""><h1><b><span>Algorithm </span><span>: Backtrack Algorithm using N-Queens as a problem</span></b></h1><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -Gaurav Sehrawat</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10104770</p><b id="docs-internal-guid-e359544a-ffae-2e2c-7d05-387152cad746"><br><span></span></b><h2><b><span>Description:</span><span> This algorithm deals with arranging N queens on a NxN chess board without attacking each other and finding all possible.</span></b></h2><p><b><br><span></span></b></p><h1><b><span>History: How over a period of time the Algorithm evolved ?</span></b></h1><p><span>The problem was started by Max Bezzel as eight queen problem where one was to find ways to arrange 8 queen without any two attacking each . </span></p><p><span>This 8 queen problem evolved as N queens problem over the period of time worked by many algorithmist and mathematician including Gauss. </span></p><p><br><span></span></p><p><span>First solution was proposed by Frank Nauz originally for 8 queens then further extended to N-queens . Further solution using deteminant was provided by S. Gunter . </span></p><p><span>But these algorithms were not efficient for O(N) time. Edgser Dijkstra solved this problem very efficiently using Depth-first Backtrack Algorithm .</span></p><p><b><br><span></span></b></p><h1><b><span>How the Backtrack Algorithm works ?</span></b></h1><p><b><span>Backtrack algorithm </span><span>uses recursion heavily and based on it.</span></b></p><p><b><span>* Each recursive call attempts to place queen in a column . </span></b></p><p><b><span>* For a given call state of boards is known in that recursive </span></b></p><p><b><span>* If the current placement of queen does not lead to a solution. The queen is removed and moved down the column.</span></b></p><p><b><span>* When all column have been tried . Recursive call terminates and backtrack to previous call.</span></b></p><p><b><span>* Pruning : If a queen cannot be placed in column i , donâ€™t hoop over to i+1 instead </span><span>backtrack</span><span> to column i-1 and shift that queen.</span></b></p><p><b><span>*Count solution and move back to first step.</span></b></p><p><b><br><span></span><br><span></span></b></p><h1><b><span>Pseduo-Code:</span></b></h1><p><b><span>1. Place the first queen in the left upper corner of the table.</span></b></p><p><b><span>2. Save the attacked positions.</span></b></p><p><b><span>3. Move to the next queen (which can only be placed to the next line).</span></b></p><p><b><span>4. Search for a valid position. If there is one go to step 8.</span></b></p><p><b><span>5. There is not a valid position for the queen. Delete it (the x coordinate is 0).</span></b></p><p><b><span>6. Move to the previous queen.</span></b></p><p><b><span>7. Go to step 4.</span></b></p><p><b><span>8. Place it to the first valid position.</span></b></p><p><b><span>9. Save the attacked positions.</span></b></p><p><b><span>10. If the queen processed is the last stop otherwise go to step 3.</span></b></p><p><br></p><p style=""><b>Sample Example on chessboard of 4x4</b></p><figure class="figure" title=""><div class="title">Demo</div><img draggable="false" alt="Backtrack Algorithm" class="aloha-image-uploading ui-resizable" style="height: 379px; width: 528px; position: static; margin: 0px; resize: none; zoom: 1; display: inline-block;" src="../resources/1be7a14e362a19f8fc39c874c0943fb164597208"><figcaption>4x4</figcaption></figure><p style=""><br></p><p style=""><br></p><p style=""><br></p><p style=""><b><br style=""><span></span><br><span></span></b></p><h1><b><span>How Backtracking might have been thought in general and used for N-Queen to demonstrate ?</span></b></h1><p><span>Behind every Algorithm there is long history of evolution. A simple quick sort algorithm has evolved through decade of sorting algorithms . Backtracing for N Queens &nbsp;Algorithm evolved through a decade . So a lot brain storm might have helped to find a solution .</span></p><p><span>Mathematician helped them to think in algebra concepts but Backtracking is Computer derivative of Recursion . </span></p><p><span>Recursion might have struck Dijkstra while doing some recursion problem and finding that N-Queen can solved using it because one is passing previous results into the next recursion call if it satisfies a condition then keep proceeding . If it fails backtrack to previous call and rectify it .</span></p><p><span>So recursion in itself is not backtracking . But Dijkstra might have thought it as during thought process to save the state and jump back to previous state and correct that state. </span></p><p><br><span></span></p><p><span>Moreover It can be thought as an analogy to nature rule of destroying what is wrong and start over from correct end. Analogy of joining the correct threads. </span></p><p><br><span></span><br><span></span></p><h1><span>How i could have thought of Backtracking Algorithm ?</span></h1><p><br><span></span></p><p><span>First of all i would have tried to solve the problem using chess board . Observing pattern is important to me . I would have started from very basic 8x8 chess board . First find a general solution to it using the following approaches:</span></p><p><span>1.Examplify:</span><span> Taking an example and analysing it.</span></p><p><span>2.Pattern Matching: </span><span>Pattern matching with other problem.</span></p><p><span>3.Simplify and generalise: </span><span>Simplifying the problem into alternative domain like mathematics or physics.</span></p><p><span>4.Base Case and Build : </span><span>Trying 3x3 then 4x4 and so on</span></p><p><span>5.Data Structure Brainstorm:</span><span> </span><span>Using trees and graphs knowledge and manipulate it in terms of it.</span></p><p><span></span>Which to apply depends on lot of experience in handling the nature of problem . Problem involves artificial intelligence . I would have thought of basic AI techniques and thus might have come to recursion and gave it a thought .&nbsp;</p><p><span></span><span> </span></p><p>I might have used Dynamic programming but yes there will be lots of mistakes and correction while choosing a solution. I would have come to backtracking eventually since i have been learning things pragmatically.&nbsp;</p><p><br></p><p><br></p><h1>Conclusion:</h1><p>A lot of ideas come through experience in handling diversity of problem and also a specific domain helps to handle a problem in different approach . So computer science concepts of recursion helped Dijkstra to explore solution with confidence and make it for N-Queen apart from 8 - Queens.&nbsp;</p><p><br></p><p><br></p>
</body></html>